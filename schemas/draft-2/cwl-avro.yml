- type: enum
  name: Datatype
  symbols:
    - "null"
    - boolean
    - int
    - long
    - float
    - double
    - bytes
    - string
    - record
    - enum
    - array
    - map
    - File
  doc: |
   CWL data types are based on Avro schema declarations.  Refer to the [Avro
   schema declaration
   documentation](https://avro.apache.org/docs/current/spec.html#schemas) for
   detailed information.  In addition, CWL defines [`File`](#/schema/File)
   as a special record type.

   ## Primitive types

   * **null**: no value
   * **boolean**: a binary value
   * **int**: 32-bit signed integer
   * **long**: 64-bit signed integer
   * **float**: single precision (32-bit) IEEE 754 floating-point number
   * **double**: double precision (64-bit) IEEE 754 floating-point number
   * **bytes**: sequence of 8-bit unsigned bytes
   * **string**: unicode character sequence

   ## Complex types

   * **record**: An object with one or more fields defined by name and type
   * **enum**: A value from a finite set of symbolic values
   * **array**: An ordered sequence of values
   * **map**: An unordered collection of key/value pairs

- type: record
  name: File
  fields: [
            { name: "path", type: "string" },
            { name: "checksum", type: ["null", "string"] },
            { name: "size", type: ["null", "long"] },
            {
                name: "secondaryFiles",
                type: [
                    "null",
                    {
                        type: "array",
                        items: "File"
                    }
                ]
            }
        ]

- type: record
  name: Expression
  doc: "An expression is a fragment of executable code that is evaluated by workflow
  platform in order to affect the behavior of a process."
  fields:
    - name: "class"
      type: "string"
      doc: Currently only `JavascriptExpression`

- type: record
  name: JavascriptExpression
  extends: Expression
  doc: |
    Execute [Javascript/ECMAScript
    5.1](http://www.ecma-international.org/ecma-262/5.1/) code and return a JSON value.

    Before executing the expression, the runtime must initialize a JavaScript
    variable "$job" containing a copy of the validated contents of the input object
    document.  This variable must be available in the expression's global
    namespace when the expression is evaluated.

    The runtime must also include any code defined in [`Process.expressionDefs`](#/schema/Process).

    Expressions must be evaluated in an isolated context (a "sandbox") which
    permits no side effects to leak outside the context, and permit no outside
    data to leak into the context.  Expressions must be evaluated in
    [Javascript strict
    mode](http://www.ecma-international.org/ecma-262/5.1/#sec-4.2.2).

    The order in which expressions are evaluated is undefined.

    Implementations may apply other limits, such as process isolation,
    timeouts, and operating system containers/jails to minimize the security
    risks associated with running untrusted code.

  fields:
    - name: "value"
      type: ["null", "string"]
      doc: |
        A fragment of JavaScript code.  If `value` is enclosed in braces ("{"
        and "}") then it will be interpreted as a [function
        body](http://www.ecma-international.org/ecma-262/5.1/#sec-13) for an
        anonymous, zero-argument function, and the value of the expression will
        be the value returned when this function is executed.  Otherwise, the
        code in `value` will be interpreted as a [Javascript
        expression](http://www.ecma-international.org/ecma-262/5.1/#sec-11),
        and the value of the expression will be the result of evaluating that
        expression.

    - name: "invoke"
      type:
        - "null"
        - type: array
          items: string
          doc: "Construct a Javascript function invocation.  The first element of
          the array is the function name, subsequent elements are invocation parameter."

- type: record
  name: "Ref"
  fields: [
    { name: "ref", type: "string" }
  ]
  doc: >
    A URI reference to another object.  This may refer to an object within the
    current document, to an external file, or to a labeled object within an
    external file.  To reference an object within the current document or
    an external document, the object must be labeled with an `id` field.

- type: record
  name: "CommandLineBinding"
  fields: [
    { name: "position", type: ["null", "int"] },
    { name: "prefix", type: [ "null", "string"] },
    { name: "separator", type: ["null", "string"] },
    { name: "itemSeparator", type: ["null", "string"] },
    { name: "valueFrom", type: ["null", "Expression", "Ref"] },
    { name: "loadContents", type: ["null", "boolean"] }
  ]

- type: record
  name: "OutputBinding"
  fields: [
    { name: "valueFrom", type: ["null", "Expression", "Ref"] },
    { name: "glob", type: ["null", "string"] },
    { name: "loadContents", type: ["null", "boolean"] }
    ]

- type: record
  name: "DataLink"
  fields: [
    { name: "source", type: "string" }
  ]

- type: record
  name: ExternallyDefinedInput
  fields: [
    { name: "def", type: "string" },
    {
      name: "connect",
      type: [
        "DataLink",
        {
          type: "array",
          items: "DataLink"
        }
      ]
    },
    { name: "id", type: ["null", "string"] }
  ]

- type: record
  name: ExternallyDefinedOutput
  fields: [
    { name: "def", type: "string" },
    { name: "id", type: "string" }
  ]

- type: record
  name: "Schema"
  doc: "A schema defines a parameter type."
  fields: [
    {
      name: type,
      doc: "The data type of this parameter.",
      type: [
        "Datatype",
        "Schema",
        "string",
        {
          type: "array",
          items: [ "Datatype", "Schema", "string" ]
        }
      ]
    },
    {
      name: fields,
      type: [
        "null",
        {
          type: "array",
          items: "Schema"
        }
      ],
      doc: "When `type` is `record`, defines the fields of the record."
    },
    {
      name: "symbols",
      type: [
        "null",
        {
          type: "array",
          items: "string"
        }
      ],
      doc: "When `type` is `enum`, defines the set of valid symbols."
    },
    {
      name: items,
      type: [
        "null",
        "Datatype",
        "Schema",
        "string",
        {
          type: "array",
          items: [ "Datatype", "Schema", "string" ]
        }
      ],
      doc: "When `type` is `array`, defines the type of the array elements."
    },
    {
      name: "values",
      type: [
        "null",
        "Datatype",
        "Schema",
        "string",
        {
          type: "array",
          items: [ "Datatype", "Schema", "string" ]
        }
      ],
      doc: "When `type` is `map`, defines the value type for the key/value pairs."
    }
  ]

- type: record
  name: "SchemaDef"
  extends: "Schema"
  fields: [ { name: name, type: "string" } ]

- type: record
  name: "InputSchema"
  extends: "Schema"
  "specialize": {"Schema": "InputSchema"}
  fields: [ {
    name: "connect",
    type: [
      "null",
      "DataLink",
      {
        type: "array",
        items: "DataLink"
      }
    ]
  } ]

- type: record
  name: "InputSchemaRoot"
  extends: "InputSchema"
  fields: [ { name: "id", type: "string" } ]

- type: record
  name: "CommandLineInputSchema"
  extends: "InputSchema"
  "specialize": {"InputSchema": "CommandLineInputSchema"}
  fields: [
    {
      name: "commandLineBinding",
      type: [ "null", "CommandLineBinding" ]
    }
  ]

- type: record
  name: "CommandLineInputSchemaRoot"
  extends: "CommandLineInputSchema"
  fields: [ { name: "id", type: "string" } ]

- type: record
  name: "OutputSchema"
  extends: "Schema"
  "specialize": {"Schema": "OutputSchema"}
  fields: [
    {
      name: "outputBinding",
      type: [ "null", "OutputBinding" ]
    }
  ]

- type: record
  name: "OutputSchemaRoot"
  extends: "OutputSchema"
  fields: [ { name: "id", type: "string" } ]

- type: record
  name: ProcessRequirement
  fields: [
    { name: "class", type: "string" }
  ]

- type: record
  name: "FileDef"
  fields: [
    {name: "filename", type: "string"},
    {
      name: "value",
      type: ["null", "string", "Expression"]
    }
  ]

- type: record
  name: "EnvironmentDef"
  fields: [
    {name: "env", type: "string"},
    {
      name: "value",
      type: ["null", "string", "Expression"]
    }
  ]

- type: record
  name: "Process"
  doc: |

    To execute a CWL document means to execute the `Process` object defined by
    the document.  Note that the `Process` object is abstract and cannot be
    directly executed.  If the `class` field is not specified, the
    implementation must default to the process class [`External`](\#/schema/External).

  fields:
    - name: "class"
      type: ["null", "string"]
      "doc": |
        The type of process is defined by the `class` field.  Valid values for this
        field are [`CommandLineTool`](\#/schema/CommandLineTool),
        [`ExpressionTool`](\#/schema/ExpressionTool), [`Workflow`](\#/schema/Workflow) or
        [`External`](\#/schema/External).  If the `class` field is not
        specified, the implementation must default to the process class [`External`](\#/schema/External).
    - name: "inputs"
      type: {
        type: "array",
        items: "InputSchemaRoot",
      }
      doc:
        "Defines the input parameters of the process.  This may be used to
        validate the input object or build a user interface for constructing
        the input object."
    - name: "outputs"
      type: {
        type: "array",
        items: "OutputSchemaRoot"
      }
      doc: "Defines the input parameters of the process, and
        may be used to generate and/or validate the input object."
    - name: "schemaDefs"
      type: [
        "null",
        {
          type: "array",
          items: "SchemaDef"
        }
      ]
      "doc": |
        Process objects may include the `schemaDefs` field.  This field consists of an
        array of type definitions which must be used when interpreting the `inputs` and
        `outputs` fields.  When a symbolic type is encountered that is not in
        [`Datatype`](#/schema/Datatype), the implementation must check if
        the type is defined in `schemaDefs` and use that definition.  If the type is not
        found in `schemaDefs`, it is an error.  The entries in `schemaDefs` must be
        processed in the order listed such that later schema definitions may refer to
        earlier schema definitions.
    - name: "requirements"
      type: [
        "null",
        {
          type: "array",
          items: "ProcessRequirement"
        }
      ]
      doc: >
        Declares requirements applying to either the runtime environment or the
        workflow engine that must be met in order to execute this process.  If
        an implementation cannot satisfy all requirements, or a requirement is
        listed which is not recognized by the implementation, it is a fatal
        error and the implementation must not attempt to run the process,
        unless overridden at user option.
    - name: "hints"
      type: [
        "null",
        {
          type: "array",
          items: "ProcessRequirement"
        }
      ]
      doc: >
        Declares hints applying to either the runtime environment or the
        workflow engine that may be helpful in executing this process.  It is
        not an error if an implementation cannot satisfy all hints, however
        the implementation may report a warning.
    - name: "expressionDefs"
      type: [
        "null",
        {
          type: "array",
          items: ["string", "Ref"]
        }
      ]

- type: record
  name: "CommandLineTool"
  extends: "Process"
  specialize: {"InputSchemaRoot": "CommandLineInputSchemaRoot"}
  doc: |

    A *tool* is a standalone, non-interactive command line application which is
    invoked on some input to perform computation, produce output, and then
    terminate.  In order to use a tool in a workflow, it is necessary to
    connect the inputs and outputs of the tool to upstream and downstream
    steps.  However, because of the enormous variety in syntax for input,
    invocation, and output, it is necessary to provide describe the invocation
    in detail.  The CommandLineTool process describes how to translate inputs
    to an actual program invocation and collect the resulting output.

    ## Command line binding

    The tool command line is built by applying command line bindings to the
    input object.

    If the binding object is listed in the input schema, "value" is set to the
    corresponding value for that input join the job order document.  For adapter
    records listed in "args", "value" must be provided or it is an error.  The
    "value" field may be a [reference](#references) or [expression](#expressions).
    The adapter behavior in building the command line depends on the data type of
    the value.  Note: in the event of a mismatch between the data type specified in
    the schema and the data type of the actual value (this can occur when applying
    expressions), use the data type of the actual value to select the appropriate
    behavior:

      - array: each value of the array will be added as separate command line
        entries, unless "itemSeparator" is specified (see below).

      - boolean: Indicates that this argument represents a boolean
          command-line flag. If true, indicates that the value in "prefix"
          (see below) should be added to the command line.  If false, nothing
          is added.

      - file: Add the "path" field of the file object to the command line.  Note that
            the actual path used to invoke the tool may be different due to path
            rewriting.

      - null: nothing is added to the command line.

      - number: Convert to decimal text string representation and add an entry to the
                the command line.

      - object: the value of "prefix" is added to the command line.  The contents of
                  the object may be serialized with a nested adapter, and appended to "prefix."

      - string: Added unchanged to the command line.

    ## Execution

    Once the command line is built, the tool is ready for execution.

    Tools are assumed to run in a POSIX environment.  Tools must be
    non-interactive, command line programs.  Tools must not require any kind of
    console, GUI, or web based user interaction in order to start and run to
    completion.

    The `TMPDIR` environment variable must be set in the runtime environment to
    the **designated temporary directory**.  Any files written to the
    designated temporary directory may be deleted by the workflow
    infrastructure when the tool invocation is complete.

    When the tool is initially executed, the designated designated temporary
    directory must contain a single file "job.cwl.json", which contains the
    input object.

    Output files produced by tool execution must be written to the **designated
    output directory**.  The designated output directory must be the initial
    current working in when the tool is executed.

    An implementation may forbid the tool from writing to any location in the
    runtime environment file system other than the designated temporary
    directory and designated output directory.  An implementation may provide
    read-only input files, and disallow in-place update of input files.

    Tools may be multithreaded or spawn child processes; however, when the
    parent process exits, the tool is considered finished regardless of whether
    any detached child processes are still running.

    ## Executing tools in Docker

    ## Output binding

  fields:
    - name: "baseCommand"
      doc: |
        Specifies the program to execute.  If the value is an array, the first
        element is the program to execute, and subsequent elements are placed
        at the beginning of the command line in prior to any command line
        bindings.  If the program includes a path separator character it must
        be an absolute path, otherwise it is an error.  If the program does not
        include a path separator, search the `$PATH` variable in the runtime
        environment find the absolute path of the executable.
      type: [
        "string",
        {
          type: "array",
            items: "string"
        }
      ]
    - name: "arguments"
      type: [
        "null",
        {
          type: "array",
          items: ["string", "CommandLineBinding"]
        }
      ]
    - name: "stdin"
      type: ["null", "Ref"]
      doc: |
        A reference to an input [`File`](#/schema/File) parameter whose contents must be piped
        into the command's standard input stream."
    - name: "stdout"
      type: ["null", "string", "Expression", "Ref"]
      doc: |
        Capture the command's standard output stream to a file written to
        the designated output directory.

        If `stdout` is a string, it specifies the file name to use.

        If `stdout` is an expression, the expression is evaluated and must
        return a string with the file name to use to capture stdout.  If the
        return value is not a string, or the resulting path contains illegal
        characters (such as the path separator `/`) it is an error.

        If `stdout` is a reference, the corresponding output
        [`File`](#/schema/File) parameter will be set to the file.  The output
        output file name is undefined, but may be based on the output parameter
        name.

    - name: "fileDefs"
      type: [
        "null",
        {
          type: "array",
          items: "FileDef"
        }
      ]
    - name: "environmentDefs"
      type: [
        "null",
        {
          type: "array",
          items: "EnvironmentDef"
        }
      ]

- type: record
  name: "ExpressionTool"
  extends: "Process"
  fields: [
    {
      name: "script",
      type: "Expression"
    }
  ]

- type: record
  name: "External"
  extends: "Process"
  specialize:
    InputSchemaRoot: ExternallyDefinedInput
    OutputSchemaRoot: ExternallyDefinedOutput
  doc: "An external process provides a level of indirection to instantiate a process
    defined by an external resource (another CWL document)."
  fields: [
    {
      name: "impl",
      type: "string",
      doc:  Specifies the resource that should be loaded to find the actual process definition.
    }
  ]


- type: record
  name: "Workflow"
  extends: "Process"
  fields: [
    {
      name: "steps",
      type: {
        type: "array",
        items: ["Workflow", "CommandLineTool", "ExpressionTool", "External"]
      }
    }
  ]

- type: record
  name: DockerRequirement
  extends: ProcessRequirement
  fields: [
    { name: "dockerPull", type: ["null", "string"] },
    { name: "dockerLoad", type: ["null", "string"] },
    { name: "dockerFile", type: ["null", "string"] },
    { name: "dockerImageId", type: ["null", "string"] }
  ]
